---
title: 常用标准库
date: 2024-01-31
---

# 常用标准库

**翻时即阅，勿CV，手写记忆。**

### 1. `<string>` - 字符串处理
```cpp
#include <string>

std::string str = "Hello"; // 创建字符串
str += " World"; // 连接字符串
size_t len = str.length(); // 获取字符串长度
char ch = str[0]; // 访问字符
size_t pos = str.find("World"); // 查找子字符串
bool isEqual = (str == "Hello World"); // 字符串比较
```

### 2. `<vector>` - 动态数组
```cpp
#include <vector>

std::vector<int> vec; // 创建向量
vec.push_back(1); // 添加元素
int val = vec[0]; // 访问元素
// 遍历向量
for(int i : vec) { 
    // 使用 i
}
size_t size = vec.size(); // 获取向量大小
vec.erase(vec.begin()); // 删除元素
std::find(nums.begin(), nums.end(), value_to_find) != nums.end(); //查找值
```

### 3. `<map>` - 键值对映射（基于红黑树）
```cpp
#include <map>

std::map<std::string, int> map; // 创建映射
map["apple"] = 5; // 插入键值对
int apple_count = map["apple"]; // 访问元素
bool exists = (map.find("apple") != map.end()); // 检查键是否存在
// 遍历映射
for(auto& kv : map) {
    // 使用 kv.first (键) 和 kv.second (值)
}
```

### 4. `<unordered_map>` - 键值对映射（基于哈希表）
```cpp
#include <unordered_map>

std::unordered_map<std::string, int> umap; // 创建无序映射
umap["banana"] = 3; // 插入键值对
int banana_count = umap["banana"]; // 访问元素
// 其他操作与 std::map 类似
```

### 5. `<set>` - 元素集合（基于红黑树）
```cpp
#include <set>

std::set<int> set; // 创建集合
std::set<int> numsSet(nums.begin(), nums.end()); //数组转换集合
set.insert(1); // 插入元素
bool is_present = (set.find(1) != set.end()); // 检查元素是否存在
set.erase(1); // 删除元素
// 遍历集合
for(int elem : set) {
    // 使用 elem
}
```

### 6. `<unordered_set>` - 元素集合（基于哈希表）
```cpp
#include <unordered_set>

std::unordered_set<int> uset; // 创建无序集合
std::unordered_set<int> numsSet(nums.begin(), nums.end()); //数组转换集合
uset.insert(2); // 插入元素
// 其他操作与 std::set 类似
```

### 7. `<algorithm>` - 算法库
```cpp
#include <algorithm>
#include <vector>

std::vector<int> vec = {1, 2, 3, 4, 5}; // 示例向量
std::sort(vec.begin(), vec.end()); // 排序
bool found = std::find(vec.begin(), vec.end(), 3) != vec.end(); // 查找
std::transform(vec.begin(), vec.end(), vec.begin(), [](int i){ return i * i; }); // 变换
```

### 8. `<thread>` - 多线程编程
```cpp
#include <thread>

void task() { /* 执行的任务 */ }
std::thread t(task); // 创建线程
t.join(); // 等待线程结束
// 或者 t.detach(); // 分离线程，让它独立执行
```

### 9. `<mutex>` - 互斥锁
```cpp
#include <mutex>

std::mutex mtx; // 创建互斥锁
mtx.lock(); // 锁定互斥锁
// 保护共享资源的代码
mtx.unlock(); // 解锁互斥锁

// 更安全的方式使用 std::lock_guard
std::lock_guard<std::mutex> guard(mtx); // 自动锁定和解锁
// 保护的代码
```

以上代码提供了每个库基础用法的概述。实际应用中，这些库提供的功能远不止这些，建议在需要时查

### 10. `<chrono>` - 时间

```c++
#include <chrono>

auto now = std::chrono::system_clock::now();					// 获取当前时间点
auto now_c = std::chrono::system_clock::to_time_t(now); 		// 时间点转换为时间戳
auto past = std::chrono::system_clock::from_time_t(10000000); 	// 从时间戳创建时间点
std::chrono::duration<int> thirtySeconds(30);					// 创建持续时间
auto thirtySecondsInMilliseconds = std::chrono::duration_cast<std::chrono::milliseconds>(thirtySeconds);												// 持续时间的转换
auto start = std::chrono::high_resolution_clock::now();			// 高精度时钟
auto end = std::chrono::high_resolution_clock::now();
std::chrono::duration<double> elapsed = end - start;			// 计算时间差
std::to_string(duration.count())								// 转换成字符串
std::this_thread::sleep_for(std::chrono::seconds(5));			// 睡眠等待
```

