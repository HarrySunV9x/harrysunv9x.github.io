---
title: 22种设计模式
date: 2024-01-02
---

# 22种设计模式

## 背景

开发、考试、读代码，都会接触到设计模式。在软件工程中，**设计模式**（design pattern）是对软件设计中普遍存在（反复出现）的各种问题，所提出的解决方案[维基百科]。

设计模式通常被分为三个主要类别：创建型模式、结构型模式和行为模式。本文将详尽举例每一种设计模式的用法。

本文代码示例来自：https://refactoringguru.cn/design-patterns

## 创建型

### 单例模式

单例模式是一个确保**类在任何情况下都只有一个实例**的创建型模式，并**提供一个全局访问点**来获取该实例。

它适用于控制对某些共享资源的访问，例如数据库连接或文件系统。使用单例模式可以保证所有通过该类创建的对象都访问一个共享资源的单个实例。

**问题场景**

控制某些共享资源 ，如数据库访问、文件读写以及一些自定义的场景。

**实现方式**

1. 在类中添加一个私有静态成员变量用于保存单例实例。
2. 声明一个公有静态构建方法用于获取单例实例。
3. 在静态方法中实现"延迟初始化"。 该方法会在首次被调用时创建一个新对象， 并将其存储在静态成员变量中。 此后该方法每次被调用时都返回该实例。
4. 将类的构造函数设为私有。 类的静态方法仍能调用构造函数， 但是其他对象不能调用。

**C++：**

```c++
#include "iostream"
#include "NoCopyClass.h"		// 单例类是非拷贝类

class Singleton : NoCopyClass{
private:
    // 实现方式1：在类中添加一个私有变量用于保存唯一实例
    // 指针指向唯一实例
    static Singleton *instance;

    //实现方式4：将类的构造函数设为私有。
    Singleton() {
        std::cout << "Singleton constructor" << std::endl;
    };

public:
    // 实现方式2：声明一个公有静态构建方法用于获取唯一实例
    static Singleton *getInstance();

};

// 实现方法2：声明一个公有静态构建方法用于获取唯一实例 —— 具体实现
Singleton *Singleton::getInstance() {
    // 实现方法3：首次调用时创建唯一实例
    if (instance == nullptr) {
        instance = new Singleton();
    }

    // 若已经存在实例，则直接返回
    return instance;
}

// 在C++中，在类中声明了一个静态成员变量时，还需要在类的外部提供这个变量的定义。否者会导致链接错误。
Singleton* Singleton::instance = nullptr;

void SingletonTest() {
    // 对单例的构造函数的调用替换为对其静态构建方法的调用。
    Singleton *singleton1 = Singleton::getInstance();
    Singleton *singleton2 = Singleton::getInstance();

    if (singleton1 == singleton2) {
        std::cout << "singleton success" << std::endl;
    }
}
```

**Python：**

```python
class SingletonMeta(type):
    """
    单例模式可以在 Python 中以不同的方式实现。一些可能的方法包括：基类、装饰器、元类。
    我们将使用元类，因为它最适合这个目的。
    """

    _instances = {}

    def __call__(cls, *args, **kwargs):
        """
        对 `__init__` 参数值的可能更改不会影响返回的实例。
        """
        if cls not in cls._instances:
            instance = super().__call__(*args, **kwargs)
            cls._instances[cls] = instance
        return cls._instances[cls]


class Singleton(metaclass=SingletonMeta):
    def some_business_logic(self):
        """
        最后，任何单例都应该定义一些业务逻辑，在其实例上可以执行。
        """
        # ...


if __name__ == "__main__":
    # 客户端代码。

    s1 = Singleton()
    s2 = Singleton()

    if id(s1) == id(s2):
        print("单例模式生效，两个变量包含相同的实例。")
    else:
        print("单例模式失败，变量包含不同的实例。")
```

### 原型模式

原型模式允许通过**复制现有对象**来创建新对象，而不需要依赖于其具体类。

使用原型实例指定要创建对象的类型，然后通过复制这个原型来生成新的对象。这在需要创建对象的成本较高时特别有用，或者当系统需要独立于其产品的创建和表示时，通过克隆操作来避免这种成本。

**问题场景**

深拷贝——这要求既需要知道对象的私有变量，又需要知道对象的类。

**实现方式**

1. 创建原型接口， 并在其中声明 `克隆`方法。 如果你已有类层次结构， 则只需在其所有类中添加该方法即可。

2. 原型类另行定义一个以该类对象为参数的构造函数，供拷贝。

3. 克隆方法通常只有一行代码： 使用 `new`运算符调用原型版本的构造函数。 注意， 每个类都必须显式重写克隆方法并使用自身类名调用 `new`运算符。 否则， 克隆方法可能会生成父类的对象。

4. 你还可以创建一个中心化原型注册表， 用于存储常用原型。

   你可以新建一个工厂类来实现注册表， 或者在原型基类中添加一个获取原型的静态方法。 该方法必须能够根据客户端代码设定的条件进行搜索。 搜索条件可以是简单的字符串， 或者是一组复杂的搜索参数。 找到合适的原型后， 注册表应对原型进行克隆， 并将复制生成的对象返回给客户端。

   最后还要将对子类构造函数的直接调用替换为对原型注册表工厂方法的调用。

例子：

```C++
#include <iostream>
#include <string>
#include <unordered_map>

using std::string;
// 原型设计模式
//
// 目的：允许你复制现有对象，而不使你的代码依赖于它们的类。

enum Type {
    PROTOTYPE_1 = 0,
    PROTOTYPE_2
};

// 实现方式1： 创建原型接口
class Prototype {
private:
    string prototype_name;
    float prototype_field;
public:
    Prototype();

    Prototype(string prototype_name) : prototype_name(prototype_name) {
    }

    virtual ~Prototype() {}

    virtual void Method(float prototype_field) {
        this->prototype_field = prototype_field;
        std::cout << "Call Method from " << prototype_name << " with field : " << prototype_field << std::endl;
    }

    // 实现方式1： 添加克隆方法
    virtual Prototype *clone() const = 0;
};

// 原型类1
class ConcretePrototype1 : public Prototype {
private:
    float concrete_prototype_field1;

public:
    // 实现方式2： 原型类定义一个以该类对象为参数的构造函数，复制参数对象中的所有成员变量值到新建实体中。调用父类构造函数， 让父类复制其私有成员变量值。
    ConcretePrototype1(string prototype_name, float concrete_prototype_field)
            : Prototype(prototype_name), concrete_prototype_field1(concrete_prototype_field) {
    }

    // 实现方式3： 克隆方法通常只有一行代码： 使用 new 运算符调用原型版本的构造函数。
    Prototype *clone() const override {
        return new ConcretePrototype1(*this);
    }
};

// 原型类2
class ConcretePrototype2 : public Prototype {
private:
    float concrete_prototype_field2;

public:
    ConcretePrototype2(string prototype_name, float concrete_prototype_field)
            : Prototype(prototype_name), concrete_prototype_field2(concrete_prototype_field) {
    }

    Prototype *clone() const override {
        return new ConcretePrototype2(*this);
    }
};

// 实现方式4： 创建原型工厂， 用于存储常用原型。
class PrototypeFactory {
private:
    std::unordered_map<Type, Prototype *, std::hash<int>> prototypes;

    public:
    PrototypeFactory() {
        prototypes[Type::PROTOTYPE_1] = new ConcretePrototype1("PROTOTYPE_1 ", 50.f);
        prototypes[Type::PROTOTYPE_2] = new ConcretePrototype2("PROTOTYPE_2 ", 60.f);
    }

    ~PrototypeFactory() {
        delete prototypes[Type::PROTOTYPE_1];
        delete prototypes[Type::PROTOTYPE_2];
    }

    Prototype *CreatePrototype(Type type) {
        return prototypes[type]->clone();
    }
};

void Client(PrototypeFactory &prototype_factory) {
    std::cout << "Let's create a Prototype 1\n";

    Prototype *prototype = prototype_factory.CreatePrototype(Type::PROTOTYPE_1);
    prototype->Method(90);
    delete prototype;

    std::cout << "\n";

    std::cout << "Let's create a Prototype 2 \n";

    prototype = prototype_factory.CreatePrototype(Type::PROTOTYPE_2);
    prototype->Method(10);

    delete prototype;
}

void PrototypeTest() {
    PrototypeFactory *prototype_factory = new PrototypeFactory();
    Client(*prototype_factory);
    delete prototype_factory;
}
```

**实现要点**

- **原型接口**：
  - **抽象原型类**：定义一个克隆自身的接口，让具体的原型类实现这个接口。
  - **`clone` 方法**：实现复制功能，返回新的独立对象。
- **具体原型**：实现抽象原型类的接口，提供克隆（或复制）操作，返回自身的一个副本。

**注意点**

- **深拷贝与浅拷贝**：根据需要复制对象属性的复杂性选择适当的拷贝策略。本例采用了浅拷贝。
- **循环引用**：在复制过程中避免循环引用，特别是对于自引用的对象。
- **注册原型**：在需要时，可以将原型对象注册到一个管理它们的注册表中，这样可以通过名称来访问具体原型。

### 建造者模式

建造者模式是用来**构建复杂对象**的创建型模式，它允许将对象的构造过程和它的表示分离开来，使得同样的构建过程可以创建不同的表示。

这个模式特别适合于那些需要生成的对象具有大量配置选项的情况，它可以帮助我们控制对象的创建过程，以及最终对象的形态。

假设生产一辆汽车：

```c++
#include <iostream>
#include <string>
#include <memory>

// 产品：Car
class Car {
private:
    std::string engine;
    std::string seats;
    std::string infotainment;
    
public:
    void setEngine(const std::string& eng) { engine = eng; }
    void setSeats(const std::string& sts) { seats = sts; }
    void setInfotainment(const std::string& info) { infotainment = info; }
    void specifications() const {
        std::cout << "Car with Engine: " << engine
                  << ", Seats: " << seats
                  << ", Infotainment: " << infotainment
                  << std::endl;
    }
};

// 抽象建造者：CarBuilder
class CarBuilder {
public:
    virtual ~CarBuilder() {}
    virtual void buildEngine() = 0;
    virtual void buildSeats() = 0;
    virtual void buildInfotainment() = 0;
    virtual std::unique_ptr<Car> getCar() = 0;
};

// 具体建造者：SedanCarBuilder
class SedanCarBuilder : public CarBuilder {
private:
    std::unique_ptr<Car> car;
    
public:
    SedanCarBuilder() { car = std::make_unique<Car>(); }
    void buildEngine() override { car->setEngine("Sedan Engine"); }
    void buildSeats() override { car->setSeats("Sedan Seats"); }
    void buildInfotainment() override { car->setInfotainment("Basic Infotainment"); }
    std::unique_ptr<Car> getCar() override { return std::move(car); }
};

// 具体建造者：SportsCarBuilder
class SportsCarBuilder : public CarBuilder {
private:
    std::unique_ptr<Car> car;
    
public:
    SportsCarBuilder() { car = std::make_unique<Car>(); }
    void buildEngine() override { car->setEngine("Sports Engine"); }
    void buildSeats() override { car->setSeats("Sports Seats"); }
    void buildInfotainment() override { car->setInfotainment("Advanced Infotainment"); }
    std::unique_ptr<Car> getCar() override { return std::move(car); }
};

// 指挥者：Director
class Director {
public:
    void constructSportsCar(CarBuilder& builder) {
        builder.buildEngine();
        builder.buildSeats();
        builder.buildInfotainment();
    }
};

// 客户端代码
int main() {
    Director director;
    
    SportsCarBuilder sportsBuilder;
    director.constructSportsCar(sportsBuilder);
    std::unique_ptr<Car> sportsCar = sportsBuilder.getCar();
    sportsCar->specifications();

    SedanCarBuilder sedanBuilder;
    director.constructSportsCar(sedanBuilder);
    std::unique_ptr<Car> sedanCar = sedanBuilder.getCar();
    sedanCar->specifications();

    return 0;
}
```

**实现要点**

- **抽象建造者**：提供创建产品各个组成部分的接口声明。
- **具体建造者**：具体实现这些接口的类，定义和明确它所要创建的特定类型的对象的细节。
- **产品**：最终要创建的复杂对象。通常包含多个成分部分。
- **指挥者**：一个负责构造复杂对象的类。它按特定步骤使用建造者的方法来创建一个复杂对象。

**注意点**

- **可变性**：建造者隐藏了复杂对象的内部结构和创建过程，它允许对象通过多个步骤构造，并且可以更改过程和最终形态。
- **构造步骤的精细控制**：建造者模式提供了精细的控制权，能够逐步构造复杂对象的各个组成部分，并允许步骤可回溯。
- **分离责任**：通过将复杂对象的创建过程封装在其各自的建造者中，我们可以保持代码的单一职责原则，同时提高系统的可维护性。

### 工厂方法模式

工厂方法模式是一种创建型设计模式，用于**定义一个用于创建对象的接口**，让子类决定实例化哪一个类。

这种模式使得**一个类的实例化延迟到其子类**。工厂方法模式非常适合于不同情境下可能需要创建不同对象的情况，其中每个对象都是同一基类或接口的实现。

例如，在游戏开发中，可以有一个抽象类“单位”（Unit），它定义了创建单位的接口。具体的单位类型，如“坦克”、“飞机”、“大炮”和“角色”，都是这个抽象类的子类。每个子类实现了创建具体单位的方法，从而通过父类的接口创建出完整的对象。

```c++
#include <iostream>
#include <string>
#include <memory>

// 抽象产品 - Unit
class Unit {
public:
    virtual ~Unit() {}
    virtual std::string getType() const = 0;
};

// 具体产品 - Tank
class Tank : public Unit {
public:
    std::string getType() const override {
        return "Tank";
    }
};

// 具体产品 - Plane
class Plane : public Unit {
public:
    std::string getType() const override {
        return "Plane";
    }
};

// 具体产品 - Cannon
class Cannon : public Unit {
public:
    std::string getType() const override {
        return "Cannon";
    }
};

// 抽象创建者 - UnitFactory
class UnitFactory {
public:
    virtual ~UnitFactory() {}
    virtual std::unique_ptr<Unit> createUnit() const = 0;
};

// 具体创建者 - TankFactory
class TankFactory : public UnitFactory {
public:
    std::unique_ptr<Unit> createUnit() const override {
        return std::make_unique<Tank>();
    }
};

// 具体创建者 - PlaneFactory
class PlaneFactory : public UnitFactory {
public:
    std::unique_ptr<Unit> createUnit() const override {
        return std::make_unique<Plane>();
    }
};

// 具体创建者 - CannonFactory
class CannonFactory : public UnitFactory {
public:
    std::unique_ptr<Unit> createUnit() const override {
        return std::make_unique<Cannon>();
    }
};

// 主函数 - 使用工厂方法创建单位
int main() {
    TankFactory tankFactory;
    PlaneFactory planeFactory;
    CannonFactory cannonFactory;

    auto tank = tankFactory.createUnit();
    auto plane = planeFactory.createUnit();
    auto cannon = cannonFactory.createUnit();

    std::cout << "Created Unit: " << tank->getType() << std::endl;
    std::cout << "Created Unit: " << plane->getType() << std::endl;
    std::cout << "Created Unit: " << cannon->getType() << std::endl;

    return 0;
}
```

**实现要点**

- **抽象创建者（Abstract Creator）**：这是一个定义了工厂方法的类。这个方法是一个“接口”，它定义了一个创建对象的标准，但不具体实现创建对象的逻辑。在我们的游戏示例中，`UnitFactory` 就是一个抽象创建者。
- **具体创建者（Concrete Creator）**：这些是实现了抽象创建者定义的工厂方法的类。每个具体创建者类负责创建特定类型的产品。在游戏示例中，`TankFactory`、`PlaneFactory` 和 `CannonFactory` 是具体创建者。
- **抽象产品（Product）**：这是由工厂方法创建的对象的接口。它定义了产品应该有的基本特征和行为。在我们的示例中，`Unit` 是一个产品接口。
- **具体产品（Concrete Product）**：这些是实现了产品接口的具体类。它们是工厂方法创建的实际对象。在游戏中，`Tank`、`Plane` 和 `Cannon` 是具体产品。

**注意点**

- **灵活性与耦合**：工厂方法提高了代码的灵活性，减少了类之间的耦合，但可能会导致代码变得复杂。
- **扩展性**：当添加新产品时，需要创建相应的具体创建者类。
- **单一职责原则**：确保每个类的职责单一，创建者类专注于创建对象。

### 抽象工厂模式

抽象工厂模式是一个创建型设计模式，它允许你**创建一系列相关或相互依赖的对象**，而不需要指定它们具体的类。

该模式提供一个高层次的接口，用于创建一组“产品族”，每个产品族包括若干个相关的产品，而不是依赖于具体的类实现。这种模式特别适用于系统需要独立于多种产品集合的创建和呈现的情况，并且系统需要配置多个产品族之一。

假设我们定义了两种类型的文明：中世纪和未来派。每种文明都有自己的单位和建筑，由相应的具体工厂创建：

```C++
// 抽象产品：Unit
class Unit {
public:
    virtual void move() = 0; // 所有单位都应该能移动
    virtual ~Unit() {}
};

// 具体产品：Knight（中世纪骑士）
class Knight : public Unit {
public:
    void move() override {
        // 实现骑士的移动逻辑
    }
};

// 具体产品：Robot（未来机器人）
class Robot : public Unit {
public:
    void move() override {
        // 实现机器人的移动逻辑
    }
};

// 抽象产品：Building
class Building {
public:
    virtual void build() = 0; // 所有建筑都应该能被建造
    virtual ~Building() {}
};

// 具体产品：Castle（中世纪城堡）
class Castle : public Building {
public:
    void build() override {
        // 实现城堡的建造逻辑
    }
};

// 具体产品：EnergyStation（未来能源站）
class EnergyStation : public Building {
public:
    void build() override {
        // 实现能源站的建造逻辑
    }
};
// 抽象工厂（创建者）：CivilizationFactory
class CivilizationFactory {
public:
    virtual Unit* createUnit() = 0; // 创建单位的方法
    virtual Building* createBuilding() = 0; // 创建建筑的方法
    virtual ~CivilizationFactory() {}
};

// 具体工厂（创建者）：MedievalFactory（用于创建中世纪相关的产品）
class MedievalFactory : public CivilizationFactory {
public:
    Unit* createUnit() override {
        return new Knight(); // 创建中世纪骑士
    }
    Building* createBuilding() override {
        return new Castle(); // 创建中世纪城堡
    }
};

// 具体工厂（创建者）：FuturisticFactory（用于创建未来相关的产品）
class FuturisticFactory : public CivilizationFactory {
public:
    Unit* createUnit() override {
        return new Robot(); // 创建未来机器人
    }
    Building* createBuilding() override {
        return new EnergyStation(); // 创建未来能源站
    }
};
int main() {
    // 创建中世纪和未来文明的工厂
    CivilizationFactory* medievalFactory = new MedievalFactory();
    CivilizationFactory* futuristicFactory = new FuturisticFactory();

    // 使用中世纪工厂创建单位和建筑
    Unit* knight = medievalFactory->createUnit();
    Building* castle = medievalFactory->createBuilding();

    // 使用未来工厂创建单位和建筑
    Unit* robot = futuristicFactory->createUnit();
    Building* energyStation = futuristicFactory->createBuilding();

    // 示例：使用创建的对象
    knight->move();    // 骑士移动
    castle->build();   // 建造城堡
    robot->move();     // 机器人移动
    energyStation->build(); // 建造能源站

    // 清理资源
    delete knight;
    delete castle;
    delete robot;
    delete energyStation;
    delete medievalFactory;
    delete futuristicFactory;

    return 0;
}

```

**实现要点**：

- **抽象工厂**：定义一个接口用于创建相关或依赖对象的家族，而不需要明确具体类。
- **具体工厂**：实现抽象工厂的操作，制造出一系列相互关联的产品。
- **抽象产品**：为一系列相关或依赖的产品声明接口。
- **具体产品**：是抽象产品的实现对象，这些产品将组成产品家族

**注意点**：

- **一致性**：确保同一工厂生成的产品之间能够相互配合使用。
- **产品族扩展**：增加新的产品族相对容易，但在已有的产品族中添加新产品则比较困难，因为抽象工厂的接口确定后不易变动。
- **解耦**：使用抽象工厂模式可以减少客户端与具体产品类之间的依赖，客户端只需关心抽象产品和抽象工厂的接口。

可以看出，抽象工厂模式实际上也是一种工厂方法模式，只不过，其实现稍有区别：

**工厂方法模式**：

- 通常一个工厂类只有一个创建产品的方法。
- 这个方法返回一个类型的产品，不同的具体工厂会返回不同类的实例。
- 主要关注如何在不同情况下创建单一对象。

**抽象工厂模式**：

- 一个工厂类包含多个创建产品的方法。
- 每个方法返回不同类型的产品，但所有产品都属于同一个产品族。
- 具体工厂负责实现这些方法，为一个特定产品族创建所有相关产品。

- 主要关注如何创建一组对象，这些对象通常是相关的（例如，它们一起使用），而且你想确保它们之间的一致性。

## 结构型

### 代理模式

代理模式提供了一个替代品或占位符来控制对某个类的访问。通过代理模式，可以在不改变客户端代码的情况下，为系统引入新的功能和约束，增强对系统资源的控制和管理能力。这使得代码更加灵活，易于维护和扩展。

代理模式适合多种应用场景：

1. **虚拟代理**：这种代理通常用于延迟创建开销较大的对象。当对象的全面创建不是立即必需时，虚拟代理可以代表这个重对象进行某些操作。
2. **保护代理**：此代理控制对原始对象的访问。它常用于对象应有权限限制时，确保只有拥有正确权限的用户才能访问该对象。
3. **远程代理**：这种代理代表一个位于不同地址空间（例如，不同的机器）的对象。远程代理通过网络发送客户端请求，使得客户端可以像操作本地对象一样操作远程对象。
4. **日志记录代理**：此代理记录对一个对象的所有操作。这对于调试、监控和审计等场景特别有用，因为它可以提供关于对象使用的详细信息。
5. **缓存代理**：缓存代理为昂贵的操作结果提供临时存储。当多个客户端需要相同的数据时，它可以从缓存中提供这些数据，从而提高效率和响应速度。
6. **智能引用**：此代理在访问对象时执行额外的动作。例如，当对象被引用时计数，或者在对象被访问之前检查是否已经锁定。

```c++
#include <iostream>
#include <memory>

// 抽象主题
class Subject {
public:
    virtual void Request() const = 0;
};

// 真实主题
class RealSubject : public Subject {
public:
    void Request() const override {
        std::cout << "RealSubject: Handling request." << std::endl;
    }
};

// 代理
class Proxy : public Subject {
private:
    std::shared_ptr<RealSubject> real_subject_;

    bool CheckAccess() const {
        // 这里可以添加一些访问控制的逻辑
        std::cout << "Proxy: Checking access before firing a real request." << std::endl;
        return true;
    }

    void LogAccess() const {
        std::cout << "Proxy: Logging the time of request." << std::endl;
    }

public:
    Proxy(std::shared_ptr<RealSubject> real_subject) : real_subject_(real_subject) {}

    void Request() const override {
        if (this->CheckAccess()) {
            this->real_subject_->Request();
            this->LogAccess();
        }
    }
};

// 客户端代码
void ClientCode(const std::shared_ptr<Subject>& subject) {
    // ...
    subject->Request();
    // ...
}

int main() {
    std::shared_ptr<RealSubject> real_subject = std::make_shared<RealSubject>();
    std::shared_ptr<Proxy> proxy = std::make_shared<Proxy>(real_subject);
    ClientCode(proxy);
    return 0;
}
```

**实现要点**

1. **抽象主题（Subject）**：一个接口，定义了真实主题和代理的共用接口，这样在任何使用真实主题的地方都可以使用代理。
2. **真实主题（Real Subject）**：实现了抽象主题的类，定义了代理所代表的真实对象。
3. **代理（Proxy）**：维护一个对真实主题的引用，控制对真实主题的访问，并可能负责创建和删除它。

**注意点**

- 确保代理类和真实主题类实现相同的接口。
- 代理类应该尊重真实主题的生命周期，避免产生潜在的资源泄露等问题。
- 代理可能会引入一些额外的开销，需要权衡代理带来的好处和其性能开销。

从以上可以看出，实际上代理就是让真实主题作为其中的一个成员，在这个基础上增加一些操作。如此，就会有个问题：给真实主题加一些操作的函数不久可以了吗，为什么要搞一个代理呢？

然而，使用代理模式而不是直接修改真实主题的原因在于设计原则和实际应用中的一些考虑：

- **单一职责原则**
- **开闭原则**

这两个将在另外的文章进行介绍。

### 享元模式

享元模式（Flyweight Pattern）适用于大量相似对象的情况，其中许多对象的状态可以被外部化以减少内存占用。

以文本编辑器中字符的表示为例，字符的样式（如字体、大小等）可以作为内部状态，而每个字符的位置可以视为外部状态。

```c++
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>

// 代表树的类型，如纹理和颜色
class TreeType {
public:
    std::string name;
    std::string color;
    std::string texture;

    TreeType(const std::string& name, const std::string& color, const std::string& texture)
        : name(name), color(color), texture(texture) {}

    void draw(const std::string& canvas, int x, int y) {
        // 绘制树的逻辑
        std::cout << "Drawing " << name << " tree at (" << x << "," << y << ") on " << canvas << std::endl;
    }
};

// 享元工厂，用于创建和管理 TreeType 对象
class TreeFactory {
private:
    static std::unordered_map<std::string, std::shared_ptr<TreeType>> treeTypes;

public:
    static std::shared_ptr<TreeType> getTreeType(const std::string& name, const std::string& color, const std::string& texture) {
        std::string key = name + "_" + color + "_" + texture;
        auto it = treeTypes.find(key);
        if (it == treeTypes.end()) {
            auto type = std::make_shared<TreeType>(name, color, texture);
            treeTypes[key] = type;
            return type;
        }
        return it->second;
    }
};

std::unordered_map<std::string, std::shared_ptr<TreeType>> TreeFactory::treeTypes;

// 代表单个树，包含外部状态，如位置
class Tree {
private:
    int x, y;
    std::shared_ptr<TreeType> type;

public:
    Tree(int x, int y, std::shared_ptr<TreeType> type) : x(x), y(y), type(type) {}

    void draw(const std::string& canvas) {
        type->draw(canvas, x, y);
    }
};

// 森林类，管理多棵树
class Forest {
private:
    std::vector<std::shared_ptr<Tree>> trees;

public:
    void plantTree(int x, int y, const std::string& name, const std::string& color, const std::string& texture) {
        auto type = TreeFactory::getTreeType(name, color, texture);
        auto tree = std::make_shared<Tree>(x, y, type);
        trees.push_back(tree);
    }

    void draw(const std::string& canvas) {
        for (const auto& tree : trees) {
            tree->draw(canvas);
        }
    }
};

int main() {
    Forest forest;
    forest.plantTree(1, 2, "Oak", "Green", "OakTexture");
    forest.plantTree(3, 4, "Pine", "Green", "PineTexture");
    forest.plantTree(1, 2, "Oak", "Green", "OakTexture"); // Will reuse existing TreeType

    forest.draw("Canvas");
    return 0;
}

```

**实现要点**

1. **享元（Flyweight）**：通常是一个接口或抽象类，定义了享元对象的共享行为。`TreeType` 类扮演了享元的角色。它包含了所有树共享的状态，比如名字、颜色和纹理，这些是内部状态。
2. **具体享元（Concrete Flyweight）**：是实现了享元接口的具体类。`TreeType` 类不仅是享元，同时也是具体享元，因为它实现了树类型的共享功能。
3. **享元工厂（Flyweight Factory）**：负责创建和管理享元对象，确保合理地共享对象。`TreeFactory` 类管理 `TreeType` 对象的创建和存储。
4. **客户端（Client）**：使用享元对象，并维护外部状态。`Tree` 和 `Forest` 类是客户端。`Tree` 类保存了特定树的外部状态（如位置），而 `Forest` 类管理了多个树实例并在需要时使用享元工厂。

**注意点**

- **关注线程安全**：在多线程环境中，需要确保享元工厂管理享元对象的过程是线程安全的。
- **管理外部状态**：客户端应负责外部状态的管理工作，并在需要的时候将其传递给享元对象。

### 外观模式

外观模式（Facade Pattern）核心目的是提供一个统一的接口来访问子系统中的一组接口。外观模式隐藏了使用多个复杂对象的细节，并提供了一个简化的接口，使得子系统更容易使用。

```c++
#include <iostream>
#include <string>

// 模拟第三方视频文件处理类
class VideoFile {
    // ...
};

class OggCompressionCodec {
    // ...
};

class MPEG4CompressionCodec {
    // ...
};

class CodecFactory {
public:
    // 假定的方法，提取视频文件的编解码器
    static void* extract(const VideoFile& file) {
        // ...
        return nullptr; // 返回编解码器的指针（示例）
    }
};

class BitrateReader {
public:
    // 读取并处理视频文件
    static void* read(const std::string& filename, void* codec) {
        // ...
        return nullptr; // 返回处理后的数据（示例）
    }

    // 转换视频数据
    static void* convert(void* buffer, void* codec) {
        // ...
        return nullptr; // 返回转换后的数据（示例）
    }
};

class AudioMixer {
public:
    void* fix(void* result) {
        // ...
        return result; // 返回修正后的数据（示例）
    }
};

// 外观类，提供简化的视频转换接口
class VideoConverter {
public:
    void* convert(const std::string& filename, const std::string& format) {
        VideoFile file(filename);
        void* sourceCodec = CodecFactory::extract(file);

        void* destinationCodec;
        if (format == "mp4") {
            destinationCodec = new MPEG4CompressionCodec();
        } else {
            destinationCodec = new OggCompressionCodec();
        }

        void* buffer = BitrateReader::read(filename, sourceCodec);
        void* result = BitrateReader::convert(buffer, destinationCodec);
        AudioMixer mixer;
        result = mixer.fix(result);

        return result; // 返回最终的视频数据
    }
};

// 应用程序类
class Application {
public:
    void main() {
        VideoConverter converter;
        void* mp4 = converter.convert("funny-cats-video.ogg", "mp4");
        // 假设 File 类用于处理文件保存
        // File(mp4).save();
    }
};

int main() {
    Application app;
    app.main();
    return 0;
}
```

**实现要点**

1. **外观（Facade）**：提供了简单的方法来访问复杂系统的特定部分，但不隐藏系统的全部功能，并不限制直接使用子系统。`VideoConverter` 类在这个例子中确实扮演了外观的角色。
2. **子系统类（Subsystems）**：可以包含一个或多个复杂的模块，这些模块实现了系统的功能，但它们的接口可能复杂或难以理解，例如 `VideoFile`, `CodecFactory`, `BitrateReader`, `AudioMixer` 等。。

**注意点**

- **不要过度使用**：只有当子系统真的很复杂时才应该使用外观模式，否则可能会引入不必要的层次。
- **可能成为依赖聚集点**：因为外观简化了对子系统的访问，它可能会变成项目中所有通信的瓶颈。

### 装饰模式

装饰模式通过创建一个包含原始对象的特殊包装对象（即装饰者）来实现，使其可以在运行时给对象添加新的功能，而不改变其结构。装饰模式提供了一种灵活的替代方案来扩展功能，比继承更有弹性。

```c++
#include <iostream>
#include <string>

// 数据源接口
class DataSource {
public:
    virtual void writeData(const std::string& data) = 0;
    virtual std::string readData() = 0;
    virtual ~DataSource() {}
};

// 具体组件
class FileDataSource : public DataSource {
    std::string filename;
public:
    FileDataSource(const std::string& filename) : filename(filename) {}

    void writeData(const std::string& data) override {
        // 将数据写入文件
    }

    std::string readData() override {
        // 从文件读取数据
        return "data";
    }
};

// 装饰基类
class DataSourceDecorator : public DataSource {
protected:
    DataSource* wrappee;

public:
    DataSourceDecorator(DataSource* source) : wrappee(source) {}

    void writeData(const std::string& data) override {
        wrappee->writeData(data);
    }

    std::string readData() override {
        return wrappee->readData();
    }

    virtual ~DataSourceDecorator() {
        delete wrappee;
    }
};

// 加密装饰
class EncryptionDecorator : public DataSourceDecorator {
public:
    EncryptionDecorator(DataSource* source) : DataSourceDecorator(source) {}

    void writeData(const std::string& data) override {
        // 加密数据
        std::string encryptedData = "encrypted_" + data;
        wrappee->writeData(encryptedData);
    }

    std::string readData() override {
        std::string data = wrappee->readData();
        // 解密数据
        return data.substr(10); // 示例解密
    }
};

// 压缩装饰
class CompressionDecorator : public DataSourceDecorator {
public:
    CompressionDecorator(DataSource* source) : DataSourceDecorator(source) {}

    void writeData(const std::string& data) override {
        // 压缩数据
        std::string compressedData = "compressed_" + data;
        wrappee->writeData(compressedData);
    }

    std::string readData() override {
        std::string data = wrappee->readData();
        // 解压数据
        return data.substr(11); // 示例解压
    }
};

// 应用程序类
class Application {
public:
    void dumbUsageExample() {
        DataSource* source = new FileDataSource("somefile.dat");
        source->writeData("salaryRecords");

        source = new CompressionDecorator(source);
        source->writeData("salaryRecords");

        source = new EncryptionDecorator(source);
        source->writeData("salaryRecords");

        delete source; // 清理资源
    }
};

int main() {
    Application app;
    app.dumbUsageExample();
    return 0;
}
```

**实现要点**

1. **组件（Component）**：定义一个对象接口，可以给这些对象动态地添加职责。在本例，`DataSource` 充当了这个角色。它定义了所有具体组件和装饰必须实现的操作，从而使它们可互换。
2. **具体组件（Concrete Component）**：定义了一个对象，可以给这个对象添加一些额外的职责。`FileDataSource` 是具体组件。它提供了组件接口的标准实现，但还可以被装饰以增加额外的职责。
3. **装饰（Decorator）**：实现（或继承）组件接口的类，持有一个组件（Component）对象的引用，并定义一个与组件接口一致的接口。`DataSourceDecorator` 扮演这个角色。它基于组合而非继承的方式，来增加新的功能。
4. **具体装饰（Concrete Decorator）**：装饰的实现，添加职责到组件上。`EncryptionDecorator` 和 `CompressionDecorator` 是具体的装饰。它们继承或实现了装饰基类，并在标准操作中添加了额外的行为（如加密或压缩数据）。

**注意点**

- **避免复杂的装饰链**：过多的层次会使系统复杂化。
- **装饰与继承的选择**：虽然装饰提供了比继承更灵活的方式来扩展对象功能，但它可能会导致设计中出现许多小对象，且逻辑变得复杂。

### 组合模式

组合模式（Composite Pattern）是用于将对象组合成树形结构以表示部分-整体的层次结构。这使得客户端能够以统一的方式对单个对象和组合对象进行处理。

```c++
#include <iostream>
#include <vector>
using namespace std;

// 组件接口会声明组合中简单和复杂对象的通用操作。
class Graphic {
public:
    virtual void move(int x, int y) = 0;
    virtual void draw() = 0;
};

// 叶节点类代表组合的终端对象。
class Dot : public Graphic {
protected:
    int x, y;
public:
    Dot(int x, int y) : x(x), y(y) {}

    void move(int dx, int dy) override {
        x += dx;
        y += dy;
    }

    void draw() override {
        cout << "Dot at position (" << x << ", " << y << ")" << endl;
    }
};

// 所有组件类都可以扩展其他组件。
class Circle : public Dot {
    int radius;
public:
    Circle(int x, int y, int radius) : Dot(x, y), radius(radius) {}

    void draw() override {
        cout << "Circle at position (" << x << ", " << y << ") with radius " << radius << endl;
    }
};

// 组合类表示可能包含子项目的复杂组件。
class CompoundGraphic : public Graphic {
    vector<Graphic*> children;
public:
    void add(Graphic* child) {
        children.push_back(child);
    }

    void remove(Graphic* child) {
        // 从 children 中移除指定的 child
        // 这里为了简化，省略了删除逻辑
    }

    void move(int dx, int dy) override {
        for (auto& child : children) {
            child->move(dx, dy);
        }
    }

    void draw() override {
        for (auto& child : children) {
            child->draw();
        }
        // 可以添加逻辑以绘制复合图形的边界等
    }
};

// 示例使用
int main() {
    CompoundGraphic all;
    all.add(new Dot(1, 2));
    all.add(new Circle(5, 3, 10));

    // 将所需组件组合为复杂的组合组件。
    CompoundGraphic group;
    // 假设已选择了一些组件
    // group.add(...); 
    // all.remove(...);
    all.add(&group);

    // 所有组件都将被绘制。
    all.draw();

    return 0;
}
```

**实现要点**

1. **组件（Component）**：定义了叶子和容器的共有操作和接口。`Graphic` 类代表了组件接口，定义了叶子（Leaf）和组合（Composite）对象的共通操作。
2. **叶子（Leaf）**：代表组合中的对象声明接口用于访问和管理子组件，叶子对象没有子组件。`Dot` 和 `Circle` 类是叶子对象的示例。它们是组合的基本元素。
3. **组合（Composite）**：一个容器，包含了一组叶子对象。实现了组件接口中与子部件有关的操作。`CompoundGraphic` 类是一个组合对象，它可以包含叶子或其他较小的组合。

### 桥接模式

**桥接模式(Bridge Pattern)**将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。

```c++
#include <iostream>
#include <memory>

// 实现部分接口
class Device {
public:
    virtual bool isEnabled() const = 0;
    virtual void enable() = 0;
    virtual void disable() = 0;
    virtual int getVolume() const = 0;
    virtual void setVolume(int percent) = 0;
    virtual int getChannel() const = 0;
    virtual void setChannel(int channel) = 0;
    virtual ~Device() {}
};

// 具体实现：电视
class Tv : public Device {
    // Tv 类的具体实现
    // ...
};

// 具体实现：收音机
class Radio : public Device {
    // Radio 类的具体实现
    // ...
};

// 抽象部分
class RemoteControl {
protected:
    std::shared_ptr<Device> device;

public:
    RemoteControl(std::shared_ptr<Device> device) : device(device) {}

    void togglePower() {
        if (device->isEnabled())
            device->disable();
        else
            device->enable();
    }

    void volumeDown() {
        device->setVolume(device->getVolume() - 10);
    }

    void volumeUp() {
        device->setVolume(device->getVolume() + 10);
    }

    void channelDown() {
        device->setChannel(device->getChannel() - 1);
    }

    void channelUp() {
        device->setChannel(device->getChannel() + 1);
    }
};

// 扩展的抽象部分
class AdvancedRemoteControl : public RemoteControl {
public:
    using RemoteControl::RemoteControl;

    void mute() {
        device->setVolume(0);
    }
};

// 客户端代码
int main() {
    auto tv = std::make_shared<Tv>();
    RemoteControl remote(tv);
    remote.togglePower();

    auto radio = std::make_shared<Radio>();
    AdvancedRemoteControl advancedRemote(radio);
    advancedRemote.togglePower();

    return 0;
}
```

**实现要点**

1. **抽象（Abstraction）**：定义了高层控制逻辑的接口。它会保持一个指向实现部分的引用。`RemoteControl` 类扮演了这个角色。它定义了控制逻辑，并持有对实现部分（即`Device`）的引用。
2. **细化抽象（Refined Abstraction）**：扩展或细化由抽象定义的接口。`AdvancedRemoteControl`实现了`RemoteControl` 类的细化拓展。
3. **实现者（Implementor）**：定义了底层操作的接口，这些操作被抽象部分的方法所调用。`Device` 接口扮演了这个角色，它定义了所有设备必须实现的基本操作。
4. **具体实现者（Concrete Implementors）**：实现实现者接口的具体类。`Tv` 和 `Radio` 类是具体实现者，因为它们实现了 `Device` 接口。

### 适配器模式

适配器模式（Adapter Pattern）允许不兼容的接口之间进行交互。适配器模式通过包装一个类的接口并提供一个新的接口，使原本由于接口不兼容而不能一起工作的类可以协同工作。

```C++
#include <iostream>
#include <cmath>

// 圆孔
class RoundHole {
    double radius;
public:
    RoundHole(double radius) : radius(radius) {}

    double getRadius() const {
        return radius;
    }

    bool fits(const RoundPeg& peg) {
        return this->getRadius() >= peg.getRadius();
    }
};

// 圆钉
class RoundPeg {
    double radius;
public:
    RoundPeg(double radius) : radius(radius) {}

    double getRadius() const {
        return radius;
    }
};

// 方钉
class SquarePeg {
    double width;
public:
    SquarePeg(double width) : width(width) {}

    double getWidth() const {
        return width;
    }
};

// 方钉适配器
class SquarePegAdapter : public RoundPeg {
    SquarePeg peg;
public:
    SquarePegAdapter(const SquarePeg& peg) : RoundPeg(peg.getWidth() * std::sqrt(2) / 2), peg(peg) {}

    double getRadius() const {
        // 计算一个小于等于方钉宽度一半的圆的半径
        return peg.getWidth() * std::sqrt(2) / 2;
    }
};

// 客户端代码
int main() {
    RoundHole hole(5);
    RoundPeg rpeg(5);
    if (hole.fits(rpeg)) {
        std::cout << "Round peg r5 fits round hole r5." << std::endl;
    }

    SquarePeg smallSqPeg(5);
    SquarePeg largeSqPeg(10);

    // 方钉不直接与圆孔兼容，因此无法编译
    // hole.fits(smallSqPeg);

    // 使用适配器
    SquarePegAdapter smallSqPegAdapter(smallSqPeg);
    SquarePegAdapter largeSqPegAdapter(largeSqPeg);
    if (hole.fits(smallSqPegAdapter)) {
        std::cout << "Square peg w5 fits round hole r5." << std::endl;
    }
    if (!hole.fits(largeSqPegAdapter)) {
        std::cout << "Square peg w10 does not fit into round hole r5." << std::endl;
    }

    return 0;
}
```

**实现要点**

1. **目标接口（Target）**：定义了客户端使用的与特定领域相关的接口。`RoundPeg` 实际上扮演了这个角色，因为它提供了与 `RoundHole` 兼容的接口。
2. **需要适配的类（Adaptee）**：一个或多个具有不兼容接口的类。`SquarePeg` 是需要适配的类，因为它的接口与 `RoundHole` 不兼容。
3. **适配器（Adapter）**：将 `Adaptee` 的接口转换成 `Target` 接口。`SquarePegAdapter` 是适配器，它将 `SquarePeg` 的接口适配为 `RoundPeg` 的接口。

## 行为

### 访问者模式

访问者模式向一个对象结构添加新操作，而无需修改这些对象的类。这种模式创建了一个访问者对象，该对象实现了包含访问者所需执行的操作的方法。当访问者被传递给对象结构的元素时，这些元素会调用访问者的方法。

```C++
#include <iostream>
#include <vector>

// 前置声明
class ConcreteComponentA;
class ConcreteComponentB;

// 访问者接口
class Visitor {
public:
    virtual void visitConcreteComponentA(const ConcreteComponentA *element) const = 0;
    virtual void visitConcreteComponentB(const ConcreteComponentB *element) const = 0;
};

// 组件接口
class Component {
public:
    virtual ~Component() {}
    virtual void accept(Visitor *visitor) const = 0;
};

// 具体组件A
class ConcreteComponentA : public Component {
public:
    void accept(Visitor *visitor) const override {
        visitor->visitConcreteComponentA(this);
    }

    std::string exclusiveMethodOfConcreteComponentA() const {
        return "A";
    }
};

// 具体组件B
class ConcreteComponentB : public Component {
public:
    void accept(Visitor *visitor) const override {
        visitor->visitConcreteComponentB(this);
    }

    std::string specialMethodOfConcreteComponentB() const {
        return "B";
    }
};

// 具体访问者
class ConcreteVisitor1 : public Visitor {
public:
    void visitConcreteComponentA(const ConcreteComponentA *element) const override {
        std::cout << "ConcreteVisitor1: " << element->exclusiveMethodOfConcreteComponentA() << "\n";
    }

    void visitConcreteComponentB(const ConcreteComponentB *element) const override {
        std::cout << "ConcreteVisitor1: " << element->specialMethodOfConcreteComponentB() << "\n";
    }
};

// 客户端代码
int main() {
    std::vector<Component*> components = {new ConcreteComponentA, new ConcreteComponentB};
    ConcreteVisitor1 *visitor1 = new ConcreteVisitor1;
    for (const Component *comp : components) {
        comp->accept(visitor1);
    }

    for (Component *comp : components) {
        delete comp;
    }
    delete visitor1;
    return 0;
}
```

**实现要点**

1. **组件接口（Component）**：定义一个 `accept` 方法，接受一个访问者对象作为参数。
2. **具体组件（ConcreteComponent）**：实现组件接口，提供接受访问者的具体实现，以便访问者可以访问其元素。
3. **访问者接口（Visitor）**：为每种类型的具体组件声明一组访问方法。
4. **具体访问者（ConcreteVisitor）**：实现访问者接口，定义对于每种类型的具体组件的访问行为。
5. **客户端代码（Client）**：创建具体组件，并用访问者对象来访问它们。

### 模板方法模式

模板方法模式定义了一个操作中的算法的骨架，将某些步骤延迟到子类中实现。这允许子类在不改变算法结构的前提下重新定义算法的某些特定步骤。

在模板方法模式中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。

```C++
#include <iostream>

// 抽象类，定义模板方法的骨架
class AbstractClass {
public:
    // 模板方法，定义算法的骨架
    void templateMethod() const {
        this->baseOperation1();
        this->requiredOperations1();
        this->baseOperation2();
        this->hook1();
        this->requiredOperation2();
        this->baseOperation3();
        this->hook2();
    }

    // 这些操作已有实现
    void baseOperation1() const {
        std::cout << "AbstractClass says: I am doing the bulk of the work\n";
    }
    void baseOperation2() const {
        std::cout << "AbstractClass says: But I let subclasses override some operations\n";
    }
    void baseOperation3() const {
        std::cout << "AbstractClass says: But I am doing the bulk of the work anyway\n";
    }

    // 这些操作必须在子类中实现
    virtual void requiredOperations1() const = 0;
    virtual void requiredOperation2() const = 0;

    // 这是钩子，子类可以覆盖它，但不是必须的
    virtual void hook1() const {}
    virtual void hook2() const {}
};

// 具体类实现抽象类的操作
class ConcreteClass1 : public AbstractClass {
protected:
    void requiredOperations1() const override {
        std::cout << "ConcreteClass1 says: Implemented Operation1\n";
    }
    void requiredOperation2() const override {
        std::cout << "ConcreteClass1 says: Implemented Operation2\n";
    }
};

class ConcreteClass2 : public AbstractClass {
protected:
    void requiredOperations1() const override {
        std::cout << "ConcreteClass2 says: Implemented Operation1\n";
    }
    void requiredOperation2() const override {
        std::cout << "ConcreteClass2 says: Implemented Operation2\n";
    }
    void hook1() const override {
        std::cout << "ConcreteClass2 says: Overridden Hook1\n";
    }
};

// 客户端代码
void clientCode(AbstractClass *class_) {
    class_->templateMethod();
}

int main() {
    std::cout << "Same client code can work with different subclasses:\n";
    ConcreteClass1 *concreteClass1 = new ConcreteClass1;
    clientCode(concreteClass1);
    std::cout << "\n";

    std::cout << "Same client code can work with different subclasses:\n";
    ConcreteClass2 *concreteClass2 = new ConcreteClass2;
    clientCode(concreteClass2);

    delete concreteClass1;
    delete concreteClass2;
    return 0;
}
```

**实现要点**

1. **抽象类（AbstractClass）**：定义模板方法的骨架和算法的步骤。
2. **具体类（ConcreteClass）**：实现抽象类中的抽象操作，提供算法中的具体行为。
3. **模板方法（Template Method）**：在抽象类中，这是一个定义算法骨架的方法。它按顺序调用算法的步骤，其中一些步骤可以在子类中重写。
4. **钩子（Hook）**：在抽象类中提供的方法，通常不做事或默认行为。子类可以选择性地覆盖它们以影响模板方法中的算法流程。
5. **客户端代码（Client）**：使用模板方法模式的代码，可以在不知道具体类的情况下，通过抽象接口调用模板方法。

### 策略模式

策略模式是一种行为设计模式，它定义了一系列算法，并将每个算法封装起来，使它们可以互相替换。策略模式让算法的变化独立于使用算法的客户。这种模式涉及到三个主要角色：上下文（Context）、策略（Strategy）接口和具体策略（Concrete Strategies）。

在策略模式中，上下文是一个使用多种策略的类，策略接口定义了所有支持的算法的公共操作，而具体策略实现了这些算法。上下文中不实现算法逻辑，而是维护一个对策略对象的引用，并将工作委托给策略对象。

```C++
#include <iostream>
#include <memory>

// 策略接口
class Strategy {
public:
    virtual ~Strategy() {}
    virtual std::string doAlgorithm(const std::vector<std::string> &data) const = 0;
};

// 具体策略A
class ConcreteStrategyA : public Strategy {
public:
    std::string doAlgorithm(const std::vector<std::string> &data) const override {
        std::string result;
        for (std::string letter : data) {
            result += letter;
        }
        std::sort(result.begin(), result.end());
        return result;
    }
};

// 具体策略B
class ConcreteStrategyB : public Strategy {
public:
    std::string doAlgorithm(const std::vector<std::string> &data) const override {
        std::string result;
        for (std::string letter : data) {
            result += letter;
        }
        std::sort(result.begin(), result.end());
        std::reverse(result.begin(), result.end());
        return result;
    }
};

// 上下文
class Context {
private:
    std::unique_ptr<Strategy> strategy_;
public:
    Context(Strategy *strategy = nullptr) : strategy_(strategy) {}

    void setStrategy(Strategy *strategy) {
        strategy_.reset(strategy);
    }

    void doSomeBusinessLogic() const {
        // 上下文不知道具体策略的类
        std::cout << "Context: Sorting data using the strategy (not sure how it'll do it)\n";
        std::vector<std::string> data = {"a", "e", "c", "b", "d"};
        std::string result = strategy_->doAlgorithm(data);
        std::cout << result << "\n";
    }
};

// 客户端代码
int main() {
    Context *context = new Context(new ConcreteStrategyA);
    std::cout << "Client: Strategy is set to normal sorting.\n";
    context->doSomeBusinessLogic();
    std::cout << "\n";
    
    std::cout << "Client: Strategy is set to reverse sorting.\n";
    context->setStrategy(new ConcreteStrategyB);
    context->doSomeBusinessLogic();

    delete context;
    return 0;
}
```

**实现要点**

1. **策略接口（Strategy）**：定义所有支持的算法的公共接口。上下文使用这个接口来调用具体策略定义的算法。
2. **具体策略（Concrete Strategies）**：实现策略接口的类，提供具体的算法实现。
3. **上下文（Context）**：维护一个对策略对象的引用。上下文不直接实现算法，而是委托给策略对象。
4. **客户端代码（Client）**：创建具体策略对象，并将其传递给上下文。客户端知道哪种策略适合其需求，并且可以在运行时更改策略。

### 状态模式

状态模式是一种行为设计模式，它允许一个对象在其内部状态变化时改变其行为。这种模式通过将每个状态的行为封装到对应的状态类中，使得对象看上去似乎改变了其所属的类。状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。通过把状态的判断逻辑转移到表示不同状态的一系列类中，可以把复杂的判断逻辑简化。

```C++
#include <iostream>
#include <typeinfo>

// 状态接口
class State {
public:
    virtual ~State() {}

    virtual void handleRequest() = 0;
};

// 具体状态A
class ConcreteStateA : public State {
public:
    void handleRequest() override {
        std::cout << "ConcreteStateA handles request.\n";
    }
};

// 具体状态B
class ConcreteStateB : public State {
public:
    void handleRequest() override {
        std::cout << "ConcreteStateB handles request.\n";
    }
};

// 上下文
class Context {
private:
    State* state_;

public:
    Context(State* state) : state_(nullptr) {
        this->transitionTo(state);
    }

    ~Context() {
        delete state_;
    }

    void transitionTo(State* state) {
        std::cout << "Context: Transition to " << typeid(*state).name() << ".\n";
        if (this->state_ != nullptr)
            delete this->state_;
        this->state_ = state;
        this->state_->setContext(this);
    }

    void request() {
        this->state_->handleRequest();
    }
};

// 客户端代码
int main() {
    Context* context = new Context(new ConcreteStateA);
    context->request();
    context->transitionTo(new ConcreteStateB);
    context->request();

    delete context;
    return 0;
}
```

实现要点

1. **状态接口（State）**：定义一个接口以封装与上下文的一个特定状态相关的行为。
2. **具体状态（Concrete States）**：实现状态接口的类，每个子类实现一个与上下文的一个状态相关的行为。
3. **上下文（Context）**：定义客户感兴趣的接口。它维护一个指向当前状态对象的引用，并将所有与状态相关的工作委托给它。
4. **客户端代码（Client）**：创建具体状态对象和上下文，改变上下文的状态来演示不同行为。

### 观察者模式

观察者模式是一种行为设计模式，允许对象之间建立一种订阅机制，使得当一个对象的状态发生变化时，所有依赖于它的对象都会得到通知并自动更新。这种模式通常用于实现分布式事件处理系统，用于构建低耦合的系统。它包括两类对象：观察者（Observer）和被观察者（Subject）。

```C++
#include <iostream>
#include <list>
#include <string>

// 观察者接口
class Observer {
public:
    virtual ~Observer() {}
    virtual void update(const std::string &message_from_subject) = 0;
};

// 被观察者接口
class Subject {
public:
    virtual ~Subject() {}
    virtual void attach(Observer *observer) = 0;
    virtual void detach(Observer *observer) = 0;
    virtual void notify() = 0;
};

// 具体被观察者
class ConcreteSubject : public Subject {
private:
    std::list<Observer *> list_observer_;
    std::string message_;

public:
    virtual ~ConcreteSubject() {
        std::cout << "Goodbye, I was the Subject.\n";
    }

    void attach(Observer *observer) override {
        list_observer_.push_back(observer);
    }

    void detach(Observer *observer) override {
        list_observer_.remove(observer);
    }

    void notify() override {
        std::list<Observer *>::iterator iterator = list_observer_.begin();
        howManyObserver();
        while (iterator != list_observer_.end()) {
            (*iterator)->update(message_);
            ++iterator;
        }
    }

    void createMessage(std::string message = "Empty") {
        this->message_ = message;
        notify();
    }

    void howManyObserver() {
        std::cout << "There are " << list_observer_.size() << " observers in the list.\n";
    }
};

// 具体观察者
class ConcreteObserver : public Observer {
private:
    std::string message_from_subject_;
    ConcreteSubject &subject_;
    static int static_number_;
    int number_;

public:
    ConcreteObserver(ConcreteSubject &subject) : subject_(subject) {
        this->subject_.attach(this);
        std::cout << "Hi, I'm the Observer \"" << ++ConcreteObserver::static_number_ << "\".\n";
        this->number_ = ConcreteObserver::static_number_;
    }

    virtual ~ConcreteObserver() {
        std::cout << "Goodbye, I was the Observer \"" << this->number_ << "\".\n";
    }

    void update(const std::string &message_from_subject) override {
        message_from_subject_ = message_from_subject;
        printInfo();
    }

    void removeMeFromTheList() {
        subject_.detach(this);
        std::cout << "Observer \"" << number_ << "\" removed from the list.\n";
    }

    void printInfo() {
        std::cout << "Observer \"" << this->number_ << "\": a new message is available --> " << this->message_from_subject_ << "\n";
    }
};

int ConcreteObserver::static_number_ = 0;

// 客户端代码
void ClientCode() {
    ConcreteSubject *subject = new ConcreteSubject;
    ConcreteObserver *observer1 = new ConcreteObserver(*subject);
    ConcreteObserver *observer2 = new ConcreteObserver(*subject);
    ConcreteObserver *observer3 = new ConcreteObserver(*subject);
    ConcreteObserver *observer4;
    ConcreteObserver *observer5;

    subject->createMessage("Hello World! :D");
    observer3->removeMeFromTheList();

    subject->createMessage("The weather is hot today! :p");
    observer4 = new ConcreteObserver(*subject);

    observer2->removeMeFromTheList();
    observer5 = new ConcreteObserver(*subject);

    subject->createMessage("My new car is great! ;)");
    observer5->removeMeFromTheList();

    observer4->removeMeFromTheList();
    observer1->removeMeFromTheList();

    delete observer5;
    delete observer4;
    delete observer3;
    delete observer2;
    delete observer1;
    delete subject;
}

int main() {
    ClientCode();
    return 0;
}

```

**实现要点**

1. **观察者接口（Observer）**：定义了接收到通知时观察者需要执行的操作。
2. **被观察者接口（Subject）**：提供一个接口，用于附加和分离观察者对象。还包括一个通知方法，用于在状态改变时通知所有观察者。
3. **具体被观察者（Concrete Subject）**：实现被观察者接口的类，当其内部状态改变时，给所有登记过的观察者发出通知。
4. **具体观察者（Concrete Observer）**：实现观察者接口的类，定义当接收到被观察者通知时的具体行为。
5. **客户端代码（Client）**：创建具体观察者和被观察者对象，让观察者注册到被观察者，然后观察被观察者的状态变化。

### 备忘录模式

备忘录模式是一种行为设计模式，允许在不违反封装的情况下捕获并外部化一个对象的内部状态，以便以后可以将该对象恢复到此状态。这种模式通常用于实现撤销和重做功能。

备忘录模式涉及三个关键角色：原发器（Originator），备忘录（Memento）和负责人（Caretaker）。原发器是要保存状态的对象，备忘录是用于存储原发器状态的对象，而负责人则负责保存备忘录并在需要时使用它来恢复原发器的状态。

```C++
#include <iostream>
#include <vector>
#include <memory>

// 备忘录
class Memento {
public:
    virtual ~Memento() {}
    virtual std::string getName() const = 0;
    virtual std::string date() const = 0;
    virtual std::string state() const = 0;
};

// 原发器
class Originator {
private:
    std::string state_;
    std::string generateRandomString(int length = 10) {
        const char alphanum[] =
            "0123456789"
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz";
        int stringLength = sizeof(alphanum) - 1;

        std::string random_string;
        for (int i = 0; i < length; i++) {
            random_string += alphanum[std::rand() % stringLength];
        }
        return random_string;
    }

public:
    Originator(std::string state) : state_(state) {
        std::cout << "Originator: My initial state is: " << this->state_ << "\n";
    }

    void doSomething() {
        std::cout << "Originator: I'm doing something important.\n";
        this->state_ = this->generateRandomString(30);
        std::cout << "Originator: and my state has changed to: " << this->state_ << "\n";
    }

    Memento *save() {
        return new ConcreteMemento(this->state_);
    }

    void restore(Memento *memento) {
        this->state_ = memento->state();
        std::cout << "Originator: My state has changed to: " << this->state_ << "\n";
    }
};

// 具体备忘录
class ConcreteMemento : public Memento {
private:
    std::string state_;
    std::string date_;

public:
    ConcreteMemento(std::string state) : state_(state) {
        this->state_ = state;
        time_t now = time(0);
        this->date_ = ctime(&now);
    }

    std::string state() const override {
        return this->state_;
    }
    std::string getName() const override {
        return this->date_ + " / (" + this->state_.substr(0, 9) + "...)";
    }
    std::string date() const override {
        return this->date_;
    }
};

// 负责人
class Caretaker {
private:
    std::vector<Memento *> mementos_;
    Originator *originator_;

public:
    Caretaker(Originator *originator) : originator_(originator) {
        this->originator_ = originator;
    }

    void backup() {
        std::cout << "\nCaretaker: Saving Originator's state...\n";
        this->mementos_.push_back(this->originator_->save());
    }

    void undo() {
        if (!this->mementos_.size()) {
            return;
        }
        Memento *memento = this->mementos_.back();
        this->mementos_.pop_back();
        std::cout << "Caretaker: Restoring state to: " << memento->getName() << "\n";
        try {
            this->originator_->restore(memento);
        } catch (...) {
            this->undo();
        }
    }

    void showHistory() const {
        std::cout << "Caretaker: Here's the list of mementos:\n";
        for (Memento *memento : this->mementos_) {
            std::cout << memento->getName() << "\n";
        }
    }
};

// 客户端代码
void ClientCode() {
    Originator *originator = new Originator("Super-duper-super-puper-super.");
    Caretaker *caretaker = new Caretaker(originator);
    caretaker->backup();
    originator->doSomething();

    caretaker->backup();
    originator->doSomething();

    caretaker->backup();
    originator->doSomething();

    std::cout << "\n";
    caretaker->showHistory();

    std::cout << "\nClient: Now, let's rollback!\n\n";
    caretaker->undo();

    std::cout << "\nClient: Once more!\n\n";
    caretaker->undo();

    delete originator;
    delete caretaker;
}

int main() {
    std::srand(static_cast<unsigned int>(std::time(NULL)));
    ClientCode();
    return 0;
}
```

**实现要点**

1. **备忘录（Memento）**：存储原发器对象的内部状态。备忘录可以保护其内容不被原发器对象之外的任何对象所访问。
2. **原发器（Originator）**：创建一个包含其当前内部状态的备忘录对象，并可以使用备忘录对象来恢复其内部状态。
3. **负责人（Caretaker）**：负责保存备忘录对象，但不修改或检查这些备忘录对象的内容。

### 中介者模式

中介者模式是一种行为设计模式，它允许你减少多个类之间的相互依赖，从而将这些类之间的通信集中到一个中介者对象中。这种模式非常适用于系统中对象之间的关系非常复杂，相互依赖的情况。通过中介者模式，各个对象不直接通信，而是通过中介者对象来进行交互，从而使其更容易设计、理解和维护。

```c++
#include <iostream>
#include <string>

class BaseComponent;

// 中介者接口
class Mediator {
public:
    virtual void notify(BaseComponent *sender, std::string event) const = 0;
};

// 基础组件
class BaseComponent {
protected:
    Mediator *mediator_;

public:
    BaseComponent(Mediator *mediator = nullptr) : mediator_(mediator) {}

    void set_mediator(Mediator *mediator) {
        this->mediator_ = mediator;
    }
};

// 具体组件A
class ComponentA : public BaseComponent {
public:
    void doA() {
        std::cout << "Component A does A.\n";
        this->mediator_->notify(this, "A");
    }

    void doB() {
        std::cout << "Component A does B.\n";
        this->mediator_->notify(this, "B");
    }
};

// 具体组件B
class ComponentB : public BaseComponent {
public:
    void doC() {
        std::cout << "Component B does C.\n";
        this->mediator_->notify(this, "C");
    }

    void doD() {
        std::cout << "Component B does D.\n";
        this->mediator_->notify(this, "D");
    }
};

// 具体中介者
class ConcreteMediator : public Mediator {
private:
    ComponentA *componentA_;
    ComponentB *componentB_;

public:
    ConcreteMediator(ComponentA *c1, ComponentB *c2) : componentA_(c1), componentB_(c2) {
        this->componentA_->set_mediator(this);
        this->componentB_->set_mediator(this);
    }

    void notify(BaseComponent *sender, std::string event) const override {
        if (event == "A") {
            std::cout << "Mediator reacts on A and triggers following operations:\n";
            this->componentB_->doC();
        }
        if (event == "D") {
            std::cout << "Mediator reacts on D and triggers following operations:\n";
            this->componentA_->doB();
            this->componentB_->doC();
        }
    }
};

// 客户端代码
void clientCode() {
    ComponentA *c1 = new ComponentA;
    ComponentB *c2 = new ComponentB;
    ConcreteMediator *mediator = new ConcreteMediator(c1, c2);

    std::cout << "Client triggers operation A.\n";
    c1->doA();

    std::cout << "\n";
    std::cout << "Client triggers operation D.\n";
    c2->doD();

    delete c1;
    delete c2;
    delete mediator;
}

int main() {
    clientCode();
    return 0;
}
```

**实现要点**

1. **中介者接口（Mediator）**：定义用于通信的接口。中介者可以是一个接口，也可以是一个抽象类或具体类。
2. **具体中介者（Concrete Mediator）**：实现中介者的接口并协调相关对象之间的交互。具体中介者知道所有的具体组件，并负责实现它们之间的通信逻辑。
3. **基础组件（Base Component）**：包含指向中介者对象的引用。组件不直接与其他组件通信，而是通过中介者来实现交互。
4. **具体组件（Concrete Components）**：实现各自的功能，当需要与其他组件通信时，使用中介者对象。
5. **客户端代码（Client）**：负责创建组件和中介者对象，并启动它们之间的交互。

### 迭代器模式

迭代器模式是一种行为设计模式，允许你顺序地访问一个聚合对象中的元素，而无需暴露其底层的表示（列表、堆栈、树等）。这种模式提供了一种方法来访问对象的元素，而不暴露底层实现的细节。

迭代器模式涉及两个关键角色：迭代器（Iterator）和集合（Collection）。迭代器提供了遍历集合的接口，而集合则提供了创建迭代器的接口。

```C++
#include <iostream>
#include <vector>
#include <iterator>

// 迭代器接口
template <typename T, typename U>
class Iterator {
public:
    typedef typename std::vector<T>::iterator iter_type;
    virtual ~Iterator() {}

    virtual U begin() = 0;
    virtual U end() = 0;
    virtual iter_type next() = 0;
    virtual bool isDone() = 0;
    virtual iter_type current() = 0;
};

// 具体集合
template <class T>
class Container {
    friend class Iterator<T, Container<T>>;

public:
    void add(T a) {
        m_data.push_back(a);
    }

    Iterator<T, Container<T>> *createIterator() {
        return new ConcreteIterator<T, Container<T>>(this);
    }

private:
    std::vector<T> m_data;
};

// 具体迭代器
template <class T, class U>
class ConcreteIterator : public Iterator<T, U> {
public:
    ConcreteIterator(U *c) : m_container(c), m_iter(c->m_data.begin()) {}

    typename Iterator<T, U>::iter_type begin() override {
        return m_container->m_data.begin();
    }

    typename Iterator<T, U>::iter_type end() override {
        return m_container->m_data.end();
    }

    typename Iterator<T, U>::iter_type next() override {
        return ++m_iter;
    }

    bool isDone() override {
        return (m_iter == m_container->m_data.end());
    }

    typename Iterator<T, U>::iter_type current() override {
        return m_iter;
    }

private:
    U *m_container;
    typename std::vector<T>::iterator m_iter;
};

// 客户端代码
void clientCode() {
    Container<int> cont;

    for (int i = 0; i < 10; i++) {
        cont.add(i);
    }

    Iterator<int, Container<int>> *it = cont.createIterator();

    for (it->begin(); !it->isDone(); it->next()) {
        std::cout << *it->current() << std::endl;
    }

    delete it;
}

int main() {
    clientCode();
    return 0;
}
```

**实现要点**

1. **迭代器接口（Iterator）**：定义访问和遍历元素的接口。
2. **具体迭代器（Concrete Iterator）**：实现迭代器接口，负责管理迭代过程。这个类知道如何遍历集合的元素。
3. **集合（Collection）**：提供一种方式来创建一个与其容器兼容的迭代器。集合对象通常包含元素，并提供一个方法来访问迭代器实例。
4. **客户端代码（Client）**：使用迭代器模式来遍历和访问集合中的元素。

### 命令模式

命令模式是一种行为设计模式，它将请求或简单操作转换为一个对象。这种模式允许参数化客户端与请求的队列或请求的执行，并且提供了撤销操作的能力。命令模式通常用于实现事务性行为、日志请求、队列请求等。

命令模式主要涉及三个角色：命令（Command）、接收者（Receiver）和调用者（Invoker）。命令封装了对接收者的调用，调用者通过命令接口执行命令，而接收者则执行与请求相关的操作。

```C++
#include <iostream>
#include <vector>
#include <memory>

// 命令接口
class Command {
public:
    virtual ~Command() {}
    virtual void execute() const = 0;
};

// 接收者
class Receiver {
public:
    void doSomething(const std::string &a) {
        std::cout << "Receiver: Working on (" << a << ".)\n";
    }
    void doSomethingElse(const std::string &b) {
        std::cout << "Receiver: Also working on (" << b << ".)\n";
    }
};

// 具体命令
class SimpleCommand : public Command {
private:
    std::string payload_;

public:
    explicit SimpleCommand(std::string payload) : payload_(payload) {}
    void execute() const override {
        std::cout << "SimpleCommand: See, I can do simple things like printing (" << this->payload_ << ")\n";
    }
};

class ComplexCommand : public Command {
private:
    Receiver *receiver_;
    std::string a_;
    std::string b_;

public:
    ComplexCommand(Receiver *receiver, std::string a, std::string b) : receiver_(receiver), a_(a), b_(b) {}
    void execute() const override {
        std::cout << "ComplexCommand: Complex stuff should be done by a receiver object.\n";
        this->receiver_->doSomething(this->a_);
        this->receiver_->doSomethingElse(this->b_);
    }
};

// 调用者
class Invoker {
private:
    Command *on_start_;
    Command *on_finish_;

public:
    ~Invoker() {
        delete on_start_;
        delete on_finish_;
    }

    void setOnStart(Command *command) {
        this->on_start_ = command;
    }
    void setOnFinish(Command *command) {
        this->on_finish_ = command;
    }

    void doSomethingImportant() {
        std::cout << "Invoker: Does anybody want something done before I begin?\n";
        if (this->on_start_) {
            this->on_start_->execute();
        }
        std::cout << "Invoker: ...doing something really important...\n";
        std::cout << "Invoker: Does anybody want something done after I finish?\n";
        if (this->on_finish_) {
            this->on_finish_->execute();
        }
    }
};

// 客户端代码
void clientCode() {
    Invoker *invoker = new Invoker;
    invoker->setOnStart(new SimpleCommand("Say Hi!"));
    Receiver *receiver = new Receiver;
    invoker->setOnFinish(new ComplexCommand(receiver, "Send email", "Save report"));
    invoker->doSomethingImportant();

    delete invoker;
    delete receiver;
}

int main() {
    clientCode();
    return 0;
}
```

**实现要点**

1. **命令接口（Command）**：定义了执行操作的接口，通常只有一个 `execute` 方法。
2. **具体命令（Concrete Command）**：实现命令接口，定义了接收者和行为之间的绑定关系。当命令的 `execute` 方法被调用时，接收者会执行这些操作。
3. **接收者（Receiver）**：知道如何执行与执行操作请求相关的操作。
4. **调用者（Invoker）**：请求命令对象执行请求。调用者持有命令对象，并在某个时间点调用命令对象的 `execute` 方法。
5. **客户端代码（Client）**：创建具体命令对象，并设置其接收者。

### 责任链模式

责任链模式是一种行为设计模式，允许将请求沿着处理者链传递。请求从一个处理者传递到下一个处理者，直到其中一个处理者处理它为止。这种模式通常用于处理不同类型的请求，每个处理者都有机会对请求进行处理或将其传递给链上的下一个处理者。

责任链模式涉及两个关键角色：处理者（Handler）和具体处理者（Concrete Handlers）。处理者定义了处理请求的接口，而具体处理者实现了在链中处理请求的具体逻辑。

```C++
#include <iostream>
#include <vector>
#include <string>

// 抽象处理者
class Handler {
protected:
    Handler *next_handler_;

public:
    Handler() : next_handler_(nullptr) {}

    Handler* setNext(Handler *handler) {
        this->next_handler_ = handler;
        return handler;
    }

    virtual std::string handle(std::string request) {
        if (this->next_handler_) {
            return this->next_handler_->handle(request);
        }

        return {};
    }
};

// 具体处理者A
class ConcreteHandlerA : public Handler {
public:
    std::string handle(std::string request) override {
        if (request == "A") {
            return "ConcreteHandlerA: I'll handle the " + request + ".\n";
        } else {
            return Handler::handle(request);
        }
    }
};

// 具体处理者B
class ConcreteHandlerB : public Handler {
public:
    std::string handle(std::string request) override {
        if (request == "B") {
            return "ConcreteHandlerB: I'll handle the " + request + ".\n";
        } else {
            return Handler::handle(request);
        }
    }
};

// 客户端代码
void clientCode(Handler &handler) {
    std::vector<std::string> requests = {"A", "B", "C"};
    for (const std::string &request : requests) {
        const std::string result = handler.handle(request);
        if (!result.empty()) {
            std::cout << "  " << result;
        } else {
            std::cout << "  " << request << " was left untouched.\n";
        }
    }
}

int main() {
    ConcreteHandlerA *handler1 = new ConcreteHandlerA;
    ConcreteHandlerB *handler2 = new ConcreteHandlerB;
    handler1->setNext(handler2);

    std::cout << "Chain: HandlerA > HandlerB\n\n";
    clientCode(*handler1);
    std::cout << "\n";

    std::cout << "Subchain: HandlerB\n\n";
    clientCode(*handler2);

    delete handler1;
    delete handler2;

    return 0;
}
```

**实现要点**

1. **处理者接口（Handler）**：定义一个处理请求的接口，通常包括 `setNext` 方法来设置链中的下一个处理者，并包括 `handle` 方法来处理请求。
2. **具体处理者（Concrete Handlers）**：实现处理者接口的类。每个具体处理者处理它所负责的请求，然后将请求传递给链中的下一个处理者。
3. **客户端代码（Client）**：负责创建处理者链，并提交请求到链上。客户端可能不知道链中具体的处理者，只需将请求发送到链的头部。
4. **请求（Request）**：可以是一个对象，包含所有必要的信息，处理者需要这些信息来处理请求
